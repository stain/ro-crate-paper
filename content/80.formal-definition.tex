% Because this file is added with \include, do not use
% Markdown setions within.


\section{Formalizing RO-Crate in First Order Logic}

Below is an attempt to formalize the concept of RO-Crate as a set of relations using First Order Logic:

\subsection{Language}

Definition of language $\mathcal{L}_{rocrate}$:

\begin{eqnarray*}
    \mathcal{L}_{rocrate}   & \equiv & \big\{ Property(p), Class(c), 
                            Value(x), \mathbb{R}, \mathbb{S} \big\} \\
    \mathbb{D}              & \equiv & \mathbb{IRI} \\
    \mathbb{IRI}            & \equiv & { \text{IRIs as defined in RFC3987} } \\
    \mathbb{R}              & \equiv & { \text{real or integer numbers} } \\
    \mathbb{S}              & \equiv & { \text{literal strings} }
\end{eqnarray*}


\begin{markdown}
The domain of discourse $\mathbb{D}$ is the set of $\mathbb{IRI}$ identifiers [@doi:10.17487/rfc3987] (notation `<http://example.com/>`)[^3], with additional descriptions using numbers $\mathbb{R}$ (notation $13.37$) and literal strings $\mathbb{S}$ (notation $\text{“Hello”}$). 

From this formalised language $\mathcal{L}_{rocrate}$ we can interpret an RO-Crate in any representation that can gather these descriptions, their properties, classes, and literal attributes.  

[^3]:
    For simplicity, blank nodes are not included in this formalisation, as RO-Crate
    recommends the use of IRI identifiers: \url{https://www.researchobject.org/ro-crate/1.1/appendix/jsonld.html#describing-entities-in-json-ld} 
\end{markdown}

\begin{markdown}
### Minimal RO-Crate

Below we use $\mathcal{L}_{rocrate}$ to define a minimal[^4] RO-Crate:

[^4]: The full list of types, relations and attribute properties from the RO-Crate specification are not included. Examples shown include $datePublished$, $CreativeWork$ and $name$.
\end{markdown}

\begin{eqnarray*}
ROCrate(R)                                  & \models & Root(R) \land Mentions(R, R) \land hasPart(R, d) \land \\
                                            & & Mentions(R, d) \land DataEntity(d) \land \\
                                            & & Mentions(R, c) \land ContextualEntity(c) \\
\forall r \ Root(r)                         & \Rightarrow & Dataset(r) \land name(r, n) \land description(r, d) \land \\
                                            & &             published(r, date) \land license(e, l) \\
\forall e \forall n \ name(e, n)            & \Rightarrow & Value(n) \\
\forall e \forall s \ description(e, s)     & \Rightarrow & Value(s) \\
\forall e \forall d \ datePublished(e, d)   & \Rightarrow & Value(d) \\
\forall e \forall l \ license(e, l)         & \Rightarrow & ContextualEntity(l) \\
DataEntity(e)                               & \equiv &      File(e) \oplus Dataset(e) \\
Entity(e)                                   & \equiv &      DataEntity(e) \lor ContextualEntity(e) \\
\forall e \ Entity(e)                       & \Rightarrow & Class(e) \\
Mentions(R, s)                              & \models &     Relation(s, p, e) \oplus Attribute(s,  p, l) \\
Relation(s, p, o)                           & \models &     Entity(s) \land Property(p) \land  Entity(o) \\
Attribute(s, p, v)                          & \models &     Entity(s) \land Property(p) \land Value(v) \\
Value(v)                                    & \equiv &      v \in \mathbb{R} \oplus v \in \mathbb{S}
\end{eqnarray*}

\begin{markdown}
An $ROCrate(R)$ is defined as a self-described _Root Data Entity_, which describes and contains parts (_data entities_), which are further described in _contextual entities_.  These terms align with their use in the [RO-Crate 1.1 terminology](https://www.researchobject.org/ro-crate/1.1/terminology). 

The $Root(r)$ is a type of $Dataset(r)$, and must have the metadata to literal attributes to provide a $name$, $description$ and $datePublished$, as well as a contextual entity identifying its license. These predicates correspond to the RO-Crate 1.1 [requirements for the root data entity](https://www.researchobject.org/ro-crate/1.1/root-data-entity.html#direct-properties-of-the-root-data-entity).

The concept of an $Entity(e)$ is introduced as being either a $DataEntity(e)$, a $ContextualEntity(e)$, or [both](https://www.researchobject.org/ro-crate/1.1/contextual-entities.html#contextual-vs-data-entities); and must be typed with at least one $Class(e)$. 

For simplicity in this formalization (and to assist production rules below) $R$ is a constant representing a single RO-Crate, typically written to independent RO-Crate Metadata files. $R$ is used by $Mentions(R, e)$ to indicate that $e$ is an Entity described by the RO-Crate and therefore its metadata (a set of $Relation$ and $Attribute$ predicates) form part of the RO-Crate serialization. $Relation(s, p, o)$ and $Attribute(s, p, x)$ are defined as a _subject-predicate-object_ triple pattern from an $Entity(s)$ using a $Property(p)$ to either another $Entity(o)$ or a $Value(x)$ value.
\end{markdown}

\begin{markdown}
### Example of formalized RO-Crate 

The below is an example RO-Crate represented using the above formalization, assuming a base URI of `<http://example.com/ro/123/>`:
\end{markdown}

\allowdisplaybreaks
\begin{eqnarray*}
&& ROCrate(\texttt{<http://example.com/ro/123/>}) \\
&& name(\texttt{<http://example.com/ro/123/>}, \\
&& \ \ \ \ \ \text{“Data files associated with the manuscript:Effects of …”}) \\
&& description(\texttt{<http://example.com/ro/123/}, \\
&& \ \ \ \ \ \text{“Palliative care planning for nursing home residents …”}) \\
&& license(\texttt{<http://example.com/ro/123/>}, \\ 
&& \ \ \ \ \ \texttt{<https://creativecommons.org/licenses/by-nc-sa/3.0/au/>}) \\ 
&& datePublished(\texttt{<http://example.com/ro/123/>}, \text{“2017-02-23”}) \\ 
&& hasPart(\texttt{<http://example.com/ro/123/>}, 
        \texttt{<http://example.com/ro/123/file.txt>}) \\
&& hasPart(\texttt{<http://example.com/ro/123/>}, 
        \texttt{<http://www.example.om/ro/123/folder/>}) \\
\\
&& ContextualEntity(\texttt{<https://creativecommons.org/licenses/by-nc-sa/3.0/au/>}) \\
&& name(\texttt{<https://creativecommons.org/licenses/by-nc-sa/3.0/au/>},  \\
&& \ \ \ \ \  \text{“Attribution-NonCommercial-ShareAlike 3.0 Australia (CC BY-NC-SA 3.0 AU)”}) \\
\\
&& File(\texttt{<http://example.com/ro/123/survey.csv>}) \\
&& name(\texttt{<http://example.com/ro/123/survey.csv>}, 
        \text{“Survey of care providers”}) \\
\\
&& Dataset(\texttt{<http://example.com/ro/123/interviews/>}) \\
&& name(\texttt{<http://example.com/ro/123/interviews/>},  \\
&& \ \ \ \ \  \text{“Audio recordings of care provider interviews”}) 
\end{eqnarray*}

\begin{markdown}
In reality many additional attributes from schema.org types like <http://schema.org/Dataset> and <http://schema.org/CreativeWork> would be used to further describe the RO-Crate and its entities, but as these are optional they do not form part of this formalization.

### Mapping to RDF with schema.org

A formalized RO-Crate in 
$\mathcal{L}_{rocrate}$
can be mapped to different serializations.

Assume a simplified[^4] language 
$\mathcal{L}_{RDF}$ 
based on the [RDF abstract syntax](http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/):

[^4]: This simplification does not cover the extensive list of literal datatypes built-in to RDF 1.1, only strings and decimal real numbers. Likewise, language of literals are not included.
    
\end{markdown}

\begin{eqnarray*}
\mathcal{L}_{RDF}           & \equiv &      \big\{ Triple(s,p,o), IRI(i), BlankNode(b), Literal(s), 
    \mathbb{IRI}, \mathbb{S}, \mathbb{R}    \big\} \\
\mathbb{D}_{RDF}            & \equiv &      \mathbb{S} \\
\forall i \ IRI(i)          & \Rightarrow & i \in \mathbb{IRI} \\
\forall s \ BlankNode(s)    & \Rightarrow & s \in \mathbb{S} \\
\forall s \forall p \forall o \ 
    Triple(s,p,o)           & \Rightarrow & \Big( IRI(s) \lor BlankNode(s) \Big) \land  \\
                            & &             IRI(p) \land  \\
                            & &             \Big(IRI(o) \lor BlankNode(o) \lor Literal(o) \Big) \\
Literal(v)                  & \models &     Value(v) \land Datatype(v,t) \land IRI(t) \\
\forall v \ Value(v)        & \Rightarrow & v \in \mathbb{S} \\
LanguageTag(v, l)           & \equiv &      Datatype\big(v, \\
    && \texttt{<http://www.w3.org/1999/02/22-rdf-syntax-ns#langString>}\big)
\end{eqnarray*}

Below follows a mapping from $\mathcal{L}_{rocrate}$ to $\mathcal{L}_{RDF}$ using schema.org as vocabulary:

\begin{eqnarray*}
Property(p)         & \Rightarrow &     type(p, \texttt{<http://www.w3.org/2000/01/rdf-schema#Property>})   \\
Class(c)            & \Rightarrow &     type(c, \texttt{<http://www.w3.org/2000/01/rdf-schema#Class>})  \\
Dataset(d)          & \Rightarrow &     type(d, \texttt{<http://schema.org/Dataset>})   \\
File(f)             & \Rightarrow &     type(f, \texttt{<http://schema.org/MediaObject>})   \\
CreativeWork(e)     & \Rightarrow &     ContextualEntity(e) \land type(e, \texttt{<http://schema.org/CreativeWork>})  \\
hasPart(e, t)       & \Rightarrow &     Relation(e, \texttt{<http://schema.org/hasPart>}, t)    \\
name(e, n)          & \Rightarrow &     Attribute(e, \texttt{<http://schema.org/name>}, n)  \\
description(e, s)   & \Rightarrow &     Attribute(e, \texttt{<http://schema.org/description>}, s)   \\
datePublished(e, d) & \Rightarrow &     Attribute(e, \texttt{<http://schema.org/datePublished>}, d) \\
license(e, l)       & \Rightarrow &     Relation(e, \texttt{<http://schema.org/license>}, l) \land CreativeWork(l) \\
type(e, t)          & \Rightarrow &     Relation(e, \texttt{<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>}, t) \\
                    & & \land Class(t)   \\
String(s)           & \equiv &          Value(s) \land  s \in \mathbb{S} \\
String(s)           & \Rightarrow &     Datatype(s, \texttt{<http://www.w3.org/2001/XMLSchema#string>}) \\
Decimal(d)          & \equiv &          Value(d) \land  d \in \mathbb{R} \\
Decimal(d)          & \Rightarrow &     Datatype(d, \texttt{<http://www.w3.org/2001/XMLSchema#decimal>}) \\
Relation(s,p,o)     & \Rightarrow &     Triple(s,p,o) \land IRI(s) \land IRI(o) \\
Attribute(s,p,o)    & \Rightarrow &     Triple(s,p,o) \land IRI(s) \land Literal(o) \\
\end{eqnarray*}


\begin{markdown}
Note that in the JSON-LD serialization of RO-Crate, the expression of $Class$ and $Property$ is typically indirect: The JSON-LD `@context` maps to schema.org IRIs, which, when resolved as Linked Data, embed their formal definition as RDFa.  

### RO-Crate 1.1 Metadata File Descriptor

An important RO-Crate principle is that of being **self-describing**. Therefore the serialization of the RO-Crate into a file should also describe itself in a [Metadata File Descriptor](https://www.researchobject.org/ro-crate/1.1/root-data-entity.html#ro-crate-metadata-file-descriptor), indicating it is about (describing) the RO-Crate root data entity, and that it conformsTo a particular version of the RO-Crate specification:
\end{markdown}

\begin{eqnarray*}
about(s,o)      & \Rightarrow & Relation(s, \texttt{<http://schema.org/about>}, o)   \\
conformsTo(s,o) & \Rightarrow & Relation(s, \texttt{<http://purl.org/dc/terms/conformsTo>}, o)   \\
MetadataFile(m) & \Rightarrow & CreativeWork(m) \land about(m,R) ∧ ROCrate(R) \land    \\
                &             & conformsTo(m, \texttt{<https://w3id.org/ro/crate/1.1>})
\end{eqnarray*}

\begin{markdown}
Note that although the metadata file necessarily is an _information resource_ written to disk or served over the network (e.g. as JSON-LD), it is not considered to be a contained _part_ of the RO-Crate in the form of a _data entity_, rather it is described only as a _contextual entity_.

While in the conceptual model the _RO-Crate Metadata File_ can be seen as the top-level node that describes the _RO-Crate Root_, in the formal model (and the JSON-LD format) the metadata file descriptor is an additional contextual entity and not affecting the depth-limit of the RO-Crate.
\end{markdown}

\begin{markdown}
### Forward-chained Production Rules for JSON-LD

Combining the above predicates and schema.org mapping with rudimentary JSON templates, these forward-chaining production rules can output JSON-LD according to the RO-Crate 1.1 specification[^2]:

[^2]:
    **Limitations:** Contextual entities not related from the RO-Crate (e.g. using inverse relations to a data entity) would not be covered by the single direction $Mentions(R, s)$ production rule; see [issue 122](https://github.com/ResearchObject/ro-crate/issues/122). The $datePublished(e, date)$ rule do not include syntax checks for the ISO 8601 datetime format. Compared with RO-Crate examples, this generated JSON-LD does not use a $@context$ as the IRIs are produced unshortened, a post-step could do JSON-LD Flattening with a versioned RO-Crate context. The `@type` expansion is included for clarity, even though this is also implied by the $type(e, t)$ expansion to $Relation(e, \texttt{xsd:type})$.
\end{markdown}

\begin{eqnarray*}
Mentions(R, s) \land Relation(s,p,o)  
                        & \Rightarrow & Mentions(R, o) \\
IRI(i)                  & \Rightarrow & \texttt{"} i \texttt{"} \\
Decimal(d)              & \Rightarrow & d \\
String(s)               & \Rightarrow & \texttt{"} s \texttt{"} \\
\forall e \forall t
\ type(e, t)            & \Rightarrow & \texttt{\{"@id":}  e \texttt{,} \\
&&                               \ \  \texttt{"@type":} t \\
&&                              \texttt{\}} \\
\forall s \forall p \forall o 
\ Relation(s,p,o)  
                        & \Rightarrow &  \texttt{\{"@id":}  s \texttt{,} \\
&&                               \ \  p \texttt{: \{ "@id":} o \texttt{\}} \\
&&                              \texttt{\}} \\
\forall s \forall p \forall v
\ Attribute(s,p,v)    & \Rightarrow &  \texttt{\{"@id":} s \texttt{,} \\
&&                               \ \ p \texttt{:} v  \\
&&                               \texttt{\}} \\ 
\forall r  \forall c 
    ROCrate(r)      & \Rightarrow &  \texttt{\{ "@graph": [} \\
&& \ \ \ \ Mentions(r, c)* \\
&& \ \ \ \texttt{]} \\
&& \texttt{\}} \\
R   & \equiv & \texttt{<./>}  \\
R   & \Rightarrow &  MetadataFile(\texttt{<ro-crate-metadata.json>}) \\
\end{eqnarray*}    

\begin{markdown}
This exposes the first order logic domain of discourse of IRIs, with rational numbers and strings as their corresponding JSON-LD representation. These production rules first grow the graph of $R$ by adding a transitive rule – anything described in $R$ which is related to $o$, means that $o$ is also mentioned by the $ROCrate(R)$. For simplicity this rule is one-way; in practice the graph can also contain free-standing contextual entities that have outgoing relations to data- and contextual entities.
\end{markdown}

