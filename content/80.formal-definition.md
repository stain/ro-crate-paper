# Formalizing RO-Crate in First Order Logic {#formaldefinition}

% NOTE: Do NOT edit this file in Overleaf as the web editor seems to 
% replace some unicode characters with ï¿½
% 
% Rather than using the awkward LaTeX math mode this simply uses
% Unicode symbols like âŠ¨ within code blocks. 
% Those are rendered in font ttf-iosevka-slab using fontspec.

Below is a formalization of the concept of RO-Crate as a set of relations using First Order Logic:

## Language


Definition of language `ğ•ƒğ–—ğ–”ğ–ˆğ–—ğ–†ğ–™ğ–Š`:

```
ğ•ƒğ–—ğ–”ğ–ˆğ–—ğ–†ğ–™ğ–Š = { Property(p), Class(c), Value(x), â„, ğ•Š }
     ğ”» =  ğ•€ğ•£ğ•š
    ğ•€ğ•£ğ•š â‰¡  { IRIs as defined in RFC3987 }
     â„ â‰¡  { real or integer numbers }
     ğ•Š â‰¡  { literal strings }
```

The domain of discourse is the set of `ğ•€ğ•£ğ•š` identifiers [@doi:10.17487/rfc3987] (notation `<http://example.com/>`)[^9], with additional descriptions using numbers `â„` (notation `13.37`) and literal strings `ğ•Š` (notation `â€œHelloâ€`). 

From this formalised language `ğ•ƒğ–—ğ–”ğ–ˆğ–—ğ–†ğ–™ğ–Š` we can interpret an RO-Crate in any representation that can gather these descriptions, their properties, classes, and literal attributes.  

## Minimal RO-Crate

Below we use `ğ•ƒğ–—ğ–”ğ–ˆğ–—ğ–†ğ–™ğ–Š` to define a minimal[^8] RO-Crate:

```
                ROCrate(R) âŠ¨  Root(R) âˆ§ Mentions(R, R) âˆ§ hasPart(R, d) âˆ§ 
                               Mentions(R, d) âˆ§ DataEntity(d) âˆ§
                               Mentions(R, c) âˆ§ ContextualEntity(c)
               âˆ€r Root(r) â‡’  Dataset(r) âˆ§ name(r, n) âˆ§ 
                               description(r, d) âˆ§ 
                               datePublished(r, date) âˆ§
                               license(e, l)
          âˆ€eâˆ€n name(e, n) â‡’  Value(n)
   âˆ€eâˆ€s description(e, s) â‡’  Value(s)
 âˆ€eâˆ€d datePublished(e, d) â‡’  Value(d)
       âˆ€eâˆ€l license(e, l) â‡’  ContextualEntity(l)
             DataEntity(e) â‰¡  File(e) âŠ• Dataset(e)
                 Entity(e) â‰¡  DataEntity(e) âˆ¨ ContextualEntity(e)
              âˆ€e Entity(e) â‡’ type(e, c) âˆ§ Class(c)
    âˆ€e ContextualEntity(e) â‡’ name(e, n)
            Mentions(R, s) âŠ¨  Relation(s, p, e)  âŠ•  Attribute(s, p, l)
         Relation(s, p, o) âŠ¨  Entity(s) âˆ§ Property(p) âˆ§ Entity(o)
        Attribute(s, p, x) âŠ¨  Entity(s) âˆ§ Property(p) âˆ§ Value(x)
                  Value(x) â‰¡  x âˆˆ â„  âŠ•  x âˆˆ ğ•Š
```

An `ROCrate(R)` is defined as a self-described _Root Data Entity_, which describes and contains parts (_data entities_), which are further described in _contextual entities_.  These terms align with their use in the [RO-Crate 1.1 terminology](https://www.researchobject.org/ro-crate/1.1/terminology). 

The `Root(r)` is a type of `Dataset(r)`, and must as metadata have at least the attributes `name`, `description` and `datePublished`, as well as a contextual entity that identify its `license`. These predicates correspond to the RO-Crate 1.1 [minimal requirements for the root data entity](https://www.researchobject.org/ro-crate/1.1/root-data-entity.html#direct-properties-of-the-root-data-entity).

The concept of an `Entity(e)` is introduced as being either a `DataEntity(e)`, a `ContextualEntity(e)`, or [both](https://www.researchobject.org/ro-crate/1.1/contextual-entities.html#contextual-vs-data-entities). Any `Entity(e)` must be typed with at least one `Class(c)`, and every `ContextualEntity(e)` must also have a `name(e,n)`; this corresponding to expectations for any _referenced contextual entity_ (section \ref{sec:contextualentities}). 

For simplicity in this formalization (and to assist production rules below) `R` is a constant representing a single RO-Crate, typically written to independent RO-Crate Metadata files. `R` is used by `Mentions(R, e)` to indicate that `e` is an Entity described by the RO-Crate and therefore its metadata (a set of Relation and Attribute predicates) form part of the RO-Crate serialization. `Relation(s, p, o)` and `Attribute(s, p, x)` are defined as a _subject-predicate-object_ triple pattern from an `Entity(s)` using a `Property(p)` to either another `Entity(o)` or a `Literal(x)` value.


## Example of formalised RO-Crate 

The below is an example RO-Crate represented using the above formalization, assuming a base IRI of `http://example.com/ro/123/`:

```
RO-Crate(<http://example.com/ro/123/>)
name(<http://example.com/ro/123/, 
    â€œData files associated with the manuscript:Effects of â€¦â€)
description(<http://example.com/ro/123/, 
    â€œPalliative care planning for nursing home residents â€¦")
license(<http://example.com/ro/123/>, 
    <https://spdx.org/licenses/CC-BY-4.0>
datePublished(<http://example.com/ro/123/>, â€œ2017")
hasPart(<http://example.com/ro/123/>, <http://example.com/ro/123/survey.csv>)
hasPart(<http://example.com/ro/123/>, <http://example.com/ro/123/interviews/>)

ContextualEntity(<https://spdx.org/licenses/CC-BY-4.0>)
name(<https://spdx.org/licenses/CC-BY-4.0, 
    â€œCreative Commons Attribution 4.0â€)

ContextualEntity(<https://spdx.org/licenses/CC-BY-NC-4.0>)
name(<https://spdx.org/licenses/CC-BY-NC-4.0, 
    â€œCreative Commons Attribution Non Commercial 4.0â€)

File(<http://example.com/ro/123/survey.csv>)
name(<http://example.com/ro/123/survey.csv>, â€œSurvey of care providersâ€)

Dataset(<http://example.com/ro/123/interviews/>)
name(<http://example.com/ro/123/interviews/>, 
    â€œAudio recordings of care provider interviewsâ€)
license(<http://example.com/ro/123/interviews/>, 
    <https://spdx.org/licenses/CC-BY-NC-4.0>

```

Notable from this triple-like formalization is that a RO-Crate R is fully represented as a tree at depth 2 helped by the use of `ğ•€ğ•£ğ•š` nodes. For instance the aggregation from the root entity `hasPart(â€¦interviews/>)` is at same level as the data entityâ€™s property `license(â€¦CC-BY-NC-4.0>)` and that contextual entityâ€™s attribute name `(â€¦Non Commercial 4.0â€)`. As shown in section {@sec:jsonld}, the RO-Crate Metadata File serialization is an equivalent shallow tree, although at depth 3 to cater for the JSON-LD preamble of `"@context"` and `"@graph"`.

In reality many additional attributes and contextual types from Schema.org types like <http://schema.org/affiliation> and <http://schema.org/Organization> would be used to further describe the RO-Crate and its entities, but as these are optional (_SHOULD_ requirements) they do not form part of this formalization.


## Mapping to RDF with Schema.org

A formalised RO-Crate can be mapped to different serializations. Assume a simplified[^7] language `ğ•ƒÊ€á´…êœ°` 
based on the RDF abstract syntax [@rdfworkinggroup_2014]:

```
                ğ•ƒğ–—ğ–‰ğ–‹ = { Triple(s,p,o), IRI(i), BlankNode(b), Literal(s),
                         ğ•€ğ•£ğ•š, â„, ğ•Š }
                ğ”»ğ–—ğ–‰ğ–‹ = ğ•Š
           âˆ€i IRI(i) â‡’ i âˆˆ ğ•€ğ•£ğ•š
âˆ€sâˆ€pâˆ€o Triple(s,p,o) â‡’ï¼ˆ IRI(s) âˆ¨ BlankNode(s) ï¼‰âˆ§
                        IRI(p) âˆ§
                      ï¼ˆ IRI(o) âˆ¨ BlankNode(o) âˆ¨ Literal(o) ï¼‰
          Literal(v) âŠ¨ Value(v) âˆ§ Datatype(v,t) âˆ§ IRI(t)
         âˆ€v Value(v) â‡’ v âˆˆ ğ•Š
    LanguageTag(v,l) â‰¡ Datatype(v,
          http://www.w3.org/1999/02/22-rdf-syntax-ns#langString)
```

Below follows a mapping from `ğ•ƒğ–—ğ–”ğ–ˆğ–—ğ–†ğ–™ğ–Š` to `ğ•ƒğ–—ğ–‰ğ–‹` using Schema.org.

```
        Property(p) â‡’ type(p,
             <http://www.w3.org/2000/01/rdf-schema#Property>)
           Class(c) â‡’ type(c,
             <http://www.w3.org/2000/01/rdf-schema#Class>)
         Dataset(d) â‡’ type(d, <http://schema.org/Dataset>)
            File(f) â‡’ type(f, <http://schema.org/MediaObject>)
ContextualEntity(e) â‡’ type(e, <http://schema.org/Thing>)
    CreativeWork(e) â‡’ ContextualEntity(e) âˆ§
                        type(e, <http://schema.org/CreativeWork>)
      hasPart(e, t) â‡’ Relation(e, <http://schema.org/hasPart>, t)
         name(e, n) â‡’ Attribute(e, <http://schema.org/name>, n)
  description(e, s) â‡’ Attribute(e, <http://schema.org/description>, s)
datePublished(e, d) â‡’ Attribute(e, <http://schema.org/datePublished>, d)
      license(e, l) â‡’ Relation(e, <http://schema.org/license>, l) âˆ§
                      CreativeWork(l)
         type(e, t) â‡’ Relation(e,
             <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>, t) âˆ§
                      Class(t)
          String(s) â‰¡ Value(s) âˆ§  s âˆˆ ğ•Š
          String(s) â‡’ Datatype(s, 
             <http://www.w3.org/2001/XMLSchema#string>)
         Decimal(d) â‰¡ Value(d) âˆ§  d âˆˆ â„
         Decimal(d) â‡’ Datatype(d,
             <http://www.w3.org/2001/XMLSchema#decimal>)
    Relation(s,p,o) â‡’ Triple(s,p,o) âˆ§ IRI(s) âˆ§ IRI(o)
   Attribute(s,p,o) â‡’ Triple(s,p,o) âˆ§ IRI(s) âˆ§ Literal(o)

```

Note that in the JSON-LD serialization of RO-Crate the expression of `Class` and `Property `is typically indirect: The JSON-LD `@context` maps to Schema.org IRIs, which, when resolved as Linked Data, embeds their formal definition as RDFa. Extensions may however include such term definitions directly in the RO-Crate.


## RO-Crate 1.1 Metadata File Descriptor

An important RO-Crate principle is that of being **self-described**. Therefore the serialization of the RO-Crate into a file should also describe itself in a [Metadata File Descriptor](https://www.researchobject.org/ro-crate/1.1/root-data-entity.html#ro-crate-metadata-file-descriptor), indicating it is `about` (describing) the RO-Crate root data entity, and that it `conformsTo` a particular version of the RO-Crate specification:

```
               about(s,o) â‡’  Relation(s, <http://schema.org/about>, o)
          conformsTo(s,o) â‡’  Relation(s, 
                               <http://purl.org/dc/terms/conformsTo>, R)
MetadataFileDescriptor(m) â‡’ ï¼ˆ CreativeWork(m) âˆ§ about(m,R) âˆ§ ROCrate(R) âˆ§ 
                             conformsTo(m,
                               <https://w3id.org/ro/crate/1.1>) ï¼‰
```

Note that although the metadata file necessarily is an _information resource_ written to disk or served over the network (as JSON-LD), it is not considered to be a contained _part_ of the RO-Crate in the form of a _data entity_, rather it is described only as a _contextual entity_.

In the conceptual model the _RO-Crate Metadata File_ can be seen as the top-level node that describes the _RO-Crate Root_, however in the formal model (and the JSON-LD format) the metadata file descriptor is an additional contextual entity that is not affecting the depth-limit of the RO-Crate.


## Forward-chained Production Rules for JSON-LD

Combining the above predicates and Schema.org mapping with rudimentary JSON templates, these forward-chaining production rules can output JSON-LD according to the RO-Crate 1.1 specification[^2]:

```
 Mentions(R, s) âˆ§ Relation(s, p, o) â‡’  Mentions(R, o)
                             IRI(i) â‡’ "i"
                         Decimal(d) â‡’  d
                          String(s) â‡’ "s"
                     âˆ€eâˆ€t type(e,t) â‡’  { "@id": s,
                                         "@type": t }
                                       }     
             âˆ€sâˆ€pâˆ€o Relation(s,p,o) â‡’  { "@id": s,
                                         p: { "@id": o }
                                       }     
            âˆ€sâˆ€pâˆ€v Attribute(s,p,v) â‡’  { "@id": s,
                                         p: v 
                                       }
                   âˆ€râˆ€c  ROCrate(R) â‡’  { "@graph": [ 
                                           Mentions(r, c)* 
                                         ]
                                       }
                                  R âŠ¨  <./>
                                  R â‡’ MetadataFileDescriptor(
                                        <ro-crate-metadata.json>) 
```

This exposes the first order logic domain of discourse of IRIs, with rational numbers and strings as their corresponding JSON-LD representation. These production rules first grow the graph of `R` by adding a transitive rule that anything described in `R` which is related to `o` means that `o` is also considered mentioned by the RO-Crate `R`. For simplicity this rule is one-way; in theory the JSON-LD graph can also contain free-standing contextual entities that have outgoing relations to data- and contextual entities, but these are proposed to be bound to the root data entity with Schema.org relation <http://schema.org/mentions>.

[^2]:
    **Limitations:** Contextual entities not related from the RO-Crate (e.g. using inverse relations to a data entity) would not be covered by the single direction $Mentions(R, s)$ production rule; see [issue 122](https://github.com/ResearchObject/ro-crate/issues/122). The `datePublished(e, d)` rule do not include syntax checks for the ISO 8601 datetime format. Compared with RO-Crate examples, this generated JSON-LD does not use a `@context` as the IRIs are produced unshortened, a post-step could do JSON-LD Flattening with a versioned RO-Crate context. The `@type` expansion is included for clarity, even though this is also implied by the `type(e, t)` expansion to `Relation(e, xsd:type)`.
[^7]:
  This simplification and mapping does not cover the extensive list of literal datatypes built into RDF 1.1, only strings and decimal real numbers. Likewise, `LanguageTag` is deliberately not utillised below.
[^8]:
   The full list of types, relations and attribute properties from the RO-Crate specification are not included. Examples shown include `datePublished`, `CreativeWork` and `name`.
[^9]:
    For simplicity, blank nodes are not included in this formalization, as RO-Crate 
    [recommends the use of IRI identifiers](https://www.researchobject.org/ro-crate/1.1/appendix/jsonld.html#describing-entities-in-json-ld)
